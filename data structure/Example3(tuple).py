 #백준 11286 절댓값 힙

"""
문제 : 절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.

배열에 정수 x (x ≠ 0)를 넣는다.
배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.
프로그램은 처음에 비어있는 배열에서 시작하게 된다.

입력 : 첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.

출력 : 입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.
"""
# 문제를 풀때 솔루션은 하나가 아니다. 시간복잡도를 기준으로 효율적인 방법을 추구해야한다.

# 우선 순위 큐(min-heap) -> 비교를 할 수 있는 요소들을 넣어야 정상적으로 작동

# 1. 우선 순위 큐에 튜플을 넣는 방법
import heapq
import sys


input = sys.stdin.readline # 빠른 입출력을 위해 기본 input함수 대신 쓴다., 빠른 입출력으로 자동 변환됨
pq = []
for _ in range(int(input())): # N을 입력받아서 반복해야함
    x = int(input()) # x가 0인지 아닌지를 판별
    if x:
        heapq.heappush(pq,(abs(x), x)) # pq에 들어갈 값, x 절대값 -> abs, 튜플을 원소로 우선순위 큐에 저장(튜플끼리 비교)
    
    else:
        if pq: #heqpq가 비어있지 않은지 검사
            print(heapq.heappop(pq)[1]) # 예제 출력에 0이 있으므로 비어있지 않으면 pop 수행, 들어간 튜플 들 중 더 작은것 출력, [0]은 최대 노드이므로 제거하고 다음 작은 수인 [1]을 pop 수행
        else:
            print(0) # 비어있으면 0출력
        



